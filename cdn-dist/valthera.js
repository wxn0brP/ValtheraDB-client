var m=Object.defineProperty;var a=(c,t)=>m(c,"name",{value:t,configurable:!0});var l=class{static{a(this,"CollectionManager")}db;collection;constructor(t,e){this.db=t,this.collection=e}async add(t,e=!0){return await this.db.add(this.collection,t,e)}async find(t={},e={},n={},r={}){return await this.db.find(this.collection,t,e,n,r)}async findOne(t={},e={},n={}){return await this.db.findOne(this.collection,t,e,n)}async update(t,e,n={}){return await this.db.update(this.collection,t,e,n)}async updateOne(t,e,n={}){return await this.db.updateOne(this.collection,t,e,n)}async remove(t,e={}){return await this.db.remove(this.collection,t,e)}async removeOne(t,e={}){return await this.db.removeOne(this.collection,t,e)}async updateOneOrAdd(t,e,{add_arg:n={},context:r={},id_gen:s=!0}={}){return await this.db.updateOneOrAdd(this.collection,t,e,{add_arg:n,context:r,id_gen:s})}async toggleOne(t,e={},n={}){return await this.db.toggleOne(this.collection,t,e,n)}},y=l;function O(c){let t=[];function e(r){return typeof r=="function"?r.toString():r}a(e,"convertFunctionToString");function n(r,s=""){Object.keys(r).forEach(o=>{let i=r[o],u=s?`${s}.${o.replace(/\./g,"[dot]")}`:o;typeof i=="function"?(t.push(u),r[o]=e(i)):Array.isArray(i)?i.forEach((h,f)=>{typeof h=="function"&&(t.push(`${u}[${f}]`),i[f]=e(h))}):typeof i=="object"&&i!==null&&n(i,u)})}return a(n,"traverseAndSerialize"),n(c),{data:c,keys:t}}a(O,"serializeFunctions");var p=O;var w="0.0.1";var d=class{static{a(this,"ValtheraRemote")}remote;version=w;constructor(t){if(typeof t=="string"){let e=new URL(t),n=e.username,r=e.password;if(!n||!r)throw new Error("Invalid remote database");e.username="",e.password="";let s=e.toString().slice(0,-1);this.remote={name:n,url:s,auth:r}}else this.remote=t;this.remote.url.endsWith("/")&&(this.remote.url=this.remote.url.slice(0,-1))}async _request(t,e=[]){let n=p(e),r={db:this.remote.name,params:n.data,keys:n.keys},s=this.remote.url+"/db/"+t,o=await fetch(s,{method:"POST",headers:{"Content-Type":"application/json",Authorization:this.remote.auth},body:JSON.stringify(r)}).then(i=>i.json());if(o.err)throw new Error(o.msg);return o.result}c(t){return new y(this,t)}async getCollections(){return await this._request("getCollections",[])}async ensureCollection(t){return await this._request("ensureCollection",[t])}async issetCollection(t){return await this._request("issetCollection",[t])}async add(t,e,n=!0){return await this._request("add",[t,e,n])}async find(t,e,n={},r={},s={}){return await this._request("find",[t,e,n,r,s])}async findOne(t,e,n={},r={}){return await this._request("findOne",[t,e,n,r])}async update(t,e,n,r={}){return await this._request("update",[t,e,n,r])}async updateOne(t,e,n,r={}){return await this._request("updateOne",[t,e,n,r])}async remove(t,e,n={}){return await this._request("remove",[t,e,n])}async removeOne(t,e,n={}){return await this._request("removeOne",[t,e,n])}async updateOneOrAdd(t,e,n,r){return await this._request("updateOneOrAdd",[t,e,n,r])}async toggleOne(t,e,n,r){return await this._request("toggleOne",[t,e,n,r])}async removeCollection(t){return await this._request("removeCollection",[t])}},z=d;export{d as ValtheraRemote,z as default};
//# sourceMappingURL=valthera.js.map
